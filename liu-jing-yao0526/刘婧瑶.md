# 密码学小学期实验报告

## 实验内容及代码分析改进

### 基于网页的用户注册与登录系统

- **使用https绑定证书到域名而非IP地址 【 *PKI* *X.509* 】**

在CentOS系统上，通过openssl的方式生成证书链多级证书。首先初始化后生成根CA并自签，在此基础上生成二级CA和生成三，最后使用三级CA签发服务器证书级CA实现绑定证书到域名（ac-flask-demo.me）。将证书发送到本地后进行安装，再在浏览器中把根证书和中间证书进行导入。在本地程序中做出相应的修改后网站证书导入成功。

### 基于网页的文件上传加密与数字签名系统

- **限制文件大小：小于 10MB**

在file.py中，对文件content的大小进行判断，若是大于等于10MB则文件不能上传。

- **限制文件类型：office文档、常见图片类型**

在_init_.py中，对文件类型进行限制，若获取到的上传文件类型不在默认文件类型的范畴中，则文件无法上传。

- **匿名用户禁止上传文件**

当用户没有登录时为匿名用户，在file.py中，若要进行文件的上传操作，首先要对用户是否登陆进行验证（login_required）。如果用户为匿名用户，则此时用户无法访问file_upload.html页面进行上传操作，仅有访问shared_file.html页面的权限，该页面上匿名用户只能下载加密后的文件和签名后的文件，而没有对文件进行上传操作的选项。

- **对文件进行对称加密存储到文件系统，禁止明文存储文件** 

用户将文件上传后，服务器端在file.py中对文件进行加密，之前在user.py文件里用网站公钥加密过对称密钥，此处进行文件加密时先用网站私钥解密出对称密钥，再用解密得到的对称密钥对文件进行加密。这样就实现了文件的加密，禁止了直接将文件以明文形式存储。

- **系统对加密后文件进行数字签名**
- **（已选）文件秒传：服务器上已有的文件，客户端可以不必再重复上传了**

在file.py中对用户上传的文件进行判断，如果已存在该文件，则此文件上传失败。

### 基于网页的加密文件下载与解密

- **提供匿名用户加密后文件和关联的数字签名文件的下载**

  在file.py中读取经对称密钥加密后的加密文件并将type定义为encrypted，读取签名文件并将type定义为signature。当匿名用户进入网站后，可以访问shared_file.html页面。在该页面中，通过超链接中的type能够定位到上述加密文件或数字签名文件，以提供给匿名用户下载。

  - 客户端对下载后的文件进行数字签名验证 【 *非对称（公钥）加密* *数字签名* 】
  
  VerifyKey库来进行验签，具体过程是，将作为signing_key的编码后的网站私钥（sk_raw）生成的verify_key，经过verify_key.encode()编码之后，作为网站公钥公开。用户在本地验证时，需要下载网站公钥文件，利用VerifyKey（）还原网站公钥后即可进行验签。
  
  - 客户端对下载后的文件可以解密还原到原始文件 【 *对称解密* *密钥管理* 】
  
  在本地创建symmetric.py文件完成客户端对下载后文件解密还原的过程。分别打开从服务器端获取到的加密文件和对称密钥，再用得到的对称密钥进行解密得到明文。
  
- **提供已登录用户解密后文件下载**

在file.py中，先用网站私钥解密得到对称密钥，再由对称密钥对加密文件解密得到明文。已登录用户可以访问file.html页面，通过type=plaintext定位到file.py中相关函数以下载解密文件。

- **下载URL设置有效期（限制时间或限制下载次数），过期后禁止访问**

在file.html页面中添加javascript代码，编写change()函数对下载时限进行控制。对每一个超链接限定下载时限，从用户登录下载页面后开始倒计时，当倒计时结束后下载链接失效，用户无法下载。

- **提供静态文件的散列值下载，供下载文件完成后本地校验文件完整性 【 *散列算法* 】**

在file.py中，对文件计算散列值。已登录用户可以访问file.html页面，通过type=hashvalue定位到file.py中相关函数以下载文件散列值。在本地编写散列值计算文件，对下载到的解密文件计算散列值，再将得到的散列值和服务器端下载得到的原文件散列值进行对比，若二者相同则文件完整性得以验证。

## 遇到的问题与解决方案

1.运行示例python代码

无法运行实例python代码，初步分析后认为应该运行run.py文件，结果运行后报错。向老师请教并仔细观看视频后，理解了代码的启动过程并通过容器化方案运行代码。此处，用容器的好处就是能快速搭建起环境以运行代码。

2.关于密钥安全管理和加密文件的研究

生成密钥的函数在use.py文件中。此处导入了secert.py文件，通过调用其中的函数先随机生成一个用户的对称密钥与公私钥，再用服务器的公钥加密这些密钥，加密过后的密钥实现了安全存储。在file.py中对文件进行加密，之前在user.py文件里用网站公钥加密过对称密钥，此处进行文件加密时先用网站私钥解密出对称密钥，再拿解密得到的对称密钥对文件进行加密.

3.签名

对文件进行签名的函数是secret.py的sign函数，models下的file.py引用了这个函数，在文件存储后，用网站私钥进行数字签名。函数是运用PyNaCl库实现的，PyNaCl是libsodium库的Python实现。libsodium是一个基于NaCl开发的先进而且易用的加密库，主要用于加密、解密、签名和生成密码哈希等，同样，PyNaCl能够提供数字签名、密钥加密、公钥加密、哈希和消息身份验证、基于密码的密钥派生和密码散列功能。

理论上，在本地应该用到网站公钥进行签名验证。通过查找资料发现，本地需要使用VerifyKey库来进行验签，具体过程是，将作为signing_key的编码后的网站私钥（sk_raw）生成的verify_key，经过verify_key.encode()编码之后，作为网站公钥公开。用户在本地验证时，需要下载网站公钥文件，利用VerifyKey（）还原网站公钥后即可进行验签。

值得注意的是，若验签不成功，程序会直接报错输出“nacl.exceptions.BadSignatureError: Signature was forged or corrupt”，无法输出“验证成功！”

4.设置URL下载有效期，过期后无法下载

最初设计URL下载有效期时尝试过对整个网页设置时间限制，倒计时结束后网页自动跳转。但这显然不符合实验设计的要求。在网上查阅相关资料后，用javascript代码对网页的超链接进行时间控制，倒计时结束后URL失效，用户将不能进行下载。

5.解密 base64

在编写本地解密文件symmetric.py时，错误地将解密结果content进行了base64值的转换，导致得到的文件无法正常打开。删除对content进行了base64值的转换的部分后，文件得以正常打开。

6.使用https绑定证书到域名

在网上查阅相关资料后在Linux系统下通过openssl的方式生成了多级证书并保存到本地。将证书安装并导入到浏览器后，我们发现网站中的证书还是之前不安全的一级证书。请教过黄老师并仔细检查代码后发现，我们并没有在本地python程序中做出对应的修改。把生成的证书crt格式直接转换为pem格式后，在_init_.py中修改ssl_context对应部分后网站可以成功识别到新的多级证书。

图 初始的网站一级证书

![origin](img/origin.jpg)

图 更改后的网站多级证书

![change](img/change.jpg)

## 参考链接

https://pynacl.readthedocs.io/en/latest/signing/

https://www.cnblogs.com/gsls200808/p/4502044.html

https://blog.csdn.net/jackone12347/article/details/120041701

https://pynacl.readthedocs.io/en/latest/signing/

https://blog.csdn.net/inthat/article/details/124550307